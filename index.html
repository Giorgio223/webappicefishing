<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IceFishing Wheel</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root{
      --bg1:#eef7ff; --bg2:#cfe6ff;

      --leaf1:#2f86ff;   /* —è—Ä–∫–∏–π —Å–∏–Ω–∏–π */
      --leaf2:#8fe6ff;   /* —è—Ä–∫–∏–π –≥–æ–ª—É–±–æ–π */

      --red:#e11d48;
      --orange:#fb923c;
      --blue:#2563eb;

      --ring1:#0b1220;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      background:
        radial-gradient(900px 600px at 25% 15%, rgba(255,255,255,.95), rgba(255,255,255,0) 60%),
        radial-gradient(1200px 900px at 70% 35%, rgba(255,255,255,.65), rgba(255,255,255,0) 65%),
        radial-gradient(1400px 900px at 50% 70%, var(--bg1), var(--bg2));
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial;
      overflow:hidden;
    }

    .leftHUD{
      position:fixed;
      left:12px; top:14px;
      display:flex; align-items:center; gap:10px;
      z-index:5;
      user-select:none;
      pointer-events:none;
    }
    .cube{
      width:34px; height:34px;
      border-radius:10px;
      background: linear-gradient(135deg, rgba(255,255,255,.95), rgba(180,225,255,.75));
      border:1px solid rgba(0,0,0,.10);
      box-shadow: 0 10px 22px rgba(0,0,0,.14);
      position:relative;
    }
    .cube:after{
      content:"";
      position:absolute;
      inset:7px 8px 12px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.65);
      opacity:.9;
    }
    .hudText{
      font-weight:950;
      letter-spacing:.6px;
      color:#0b1220;
      line-height:1;
      min-width:160px;
      text-transform:uppercase;
    }
    .hudText small{
      display:block;
      font-weight:900;
      opacity:.75;
      letter-spacing:.2px;
      margin-top:3px;
      font-size:11px;
    }

    .stage{
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      padding:18px;
      gap:10px;
    }
    .wheelWrap{
      position:relative;
      width:min(430px, 92vw);
      height:min(430px, 92vw);
      filter: drop-shadow(0 26px 44px rgba(0,0,0,.25));
    }
    canvas{ width:100%; height:100%; border-radius:50%; }

    .pointer{
      position:absolute;
      top:-8px;
      left:50%;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:16px solid transparent;
      border-right:16px solid transparent;
      border-top:30px solid var(--ring1);
      filter: drop-shadow(0 10px 10px rgba(0,0,0,.25));
      pointer-events:none;
    }
    .pointer:after{
      content:"";
      position:absolute;
      left:-10px; top:-28px;
      width:0;height:0;
      border-left:10px solid transparent;
      border-right:10px solid transparent;
      border-top:18px solid rgba(255,255,255,.92);
      opacity:.9;
    }

    /* –ò—Å—Ç–æ—Ä–∏—è —Å–Ω–∏–∑—É */
    .historyBar{
      width:min(430px, 92vw);
      display:flex;
      gap:6px;
      justify-content:center;
      align-items:center;
      padding:8px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.65);
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 12px 26px rgba(0,0,0,.12);
      overflow:hidden;
    }
    .chip{
      width:16px; height:16px;
      border-radius:999px;
      border:1px solid rgba(0,0,0,.12);
      flex:0 0 auto;
      position:relative;
    }
    .chip::after{
      content:"";
      position:absolute;
      inset:4px;
      border-radius:999px;
      background: rgba(255,255,255,.55);
      opacity:.55;
    }
    .chip.fish::before{
      content:"üêü";
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:11px;
    }
    .chip.leaf::before{
      content:"üçÉ";
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:11px;
    }
  </style>
</head>
<body>
  <div class="leftHUD">
    <div class="cube"></div>
    <div class="hudText">
      <span id="hudMain">6</span>
      <small id="hudSub">–¥–æ —Å–ø–∏–Ω–∞</small>
    </div>
  </div>

  <div class="stage">
    <div class="wheelWrap">
      <div class="pointer"></div>
      <canvas id="wheel" width="900" height="900"></canvas>
    </div>
    <div class="historyBar" id="historyBar" aria-label="history"></div>
  </div>

<script>
  const tg = window.Telegram?.WebApp;
  if (tg) { tg.ready(); tg.expand(); tg.setHeaderColor?.("#eef7ff"); }

  // ====== –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø ‚Äú–∫–∞–∂–¥—ã–µ 6 —Å–µ–∫—É–Ω–¥‚Äù (–ø–æ–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ –ø–æ –≤—Ä–µ–º–µ–Ω–∏) ======
  // –í–ê–ñ–ù–û: —á—Ç–æ–±—ã —É –≤—Å–µ—Ö –±—ã–ª–æ 100% –æ–¥–∏–Ω–∞–∫–æ–≤–æ ‚Äî –Ω—É–∂–µ–Ω —Å–µ—Ä–≤–µ—Ä (—Å–ª–µ–¥—É—é—â–∏–π —à–∞–≥).
  const PERIOD_MS = 6000;

  // ====== 53 –°–ï–ö–¢–û–†–ê ======
  const N = 53;
  const step = (Math.PI * 2) / N;
  const startOffset = -Math.PI/2;

  // –ø–æ–∑–∏—Ü–∏–∏ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ)
  const IDX_HUGE = 0;
  const IDX_ORANGES = [13, 39];
  const IDX_BLUES   = [7, 20, 33, 46];

  const css = getComputedStyle(document.documentElement);
  const COLORS = {
    red:    css.getPropertyValue('--red').trim(),
    orange: css.getPropertyValue('--orange').trim(),
    blue:   css.getPropertyValue('--blue').trim(),
    leaf1:  css.getPropertyValue('--leaf1').trim(),
    leaf2:  css.getPropertyValue('--leaf2').trim(),
  };

  const sectors = Array.from({length:N}, ()=>null);

  sectors[IDX_HUGE] = { kind:"huge", label:"HUGE REDS", fill:COLORS.red, text:"#fff", icon:"fish" };
  for (const i of IDX_ORANGES) sectors[i] = { kind:"orange", label:"BIG ORANGES", fill:COLORS.orange, text:"#1b1b1b", icon:"fish" };
  for (const i of IDX_BLUES)   sectors[i] = { kind:"blue", label:"LIL' BLUES", fill:COLORS.blue, text:"#fff", icon:"fish" };

  // 46 leafs: 23/23, alternating
  let leaf1Left = 23, leaf2Left = 23;
  let toggle = 0;
  for (let i=0;i<N;i++){
    if (sectors[i]) continue;
    const wantLeaf1 = (toggle % 2 === 0);
    if (wantLeaf1 && leaf1Left > 0){
      sectors[i] = { kind:"leaf1", label:"", fill:COLORS.leaf1, text:"#fff", icon:"leaf" };
      leaf1Left--;
    } else if (!wantLeaf1 && leaf2Left > 0){
      sectors[i] = { kind:"leaf2", label:"", fill:COLORS.leaf2, text:"#fff", icon:"leaf" };
      leaf2Left--;
    } else {
      if (leaf1Left > 0){
        sectors[i] = { kind:"leaf1", label:"", fill:COLORS.leaf1, text:"#fff", icon:"leaf" };
        leaf1Left--;
      } else {
        sectors[i] = { kind:"leaf2", label:"", fill:COLORS.leaf2, text:"#fff", icon:"leaf" };
        leaf2Left--;
      }
    }
    toggle++;
  }

  // ====== CANVAS ======
  const canvas = document.getElementById("wheel");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  const outerR = Math.min(W,H)*0.47;
  const innerR = outerR*0.22;

  let angle = 0;
  let spinning = false;

  function normalize(a){
    const t = Math.PI*2;
    return ((a%t)+t)%t;
  }
  function indexAtPointer(a){
    const pointerWorld = -Math.PI/2;
    const rel = normalize(pointerWorld - a - startOffset);
    return Math.floor(rel / step);
  }

  // ==== ICONS (—Ä–∏—Å—É–µ–º –Ω–∞ canvas, –±–ª–∏–∂–µ –∫ –≤–Ω–µ—à–Ω–µ–º—É –∫—Ä–∞—é) ====
  function drawFishIcon(x,y,scale,fill){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale, scale);
    ctx.fillStyle = fill;

    ctx.beginPath();
    ctx.ellipse(0, 0, 14, 9, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-14, 0);
    ctx.lineTo(-26, -10);
    ctx.lineTo(-26, 10);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.arc(8, -2, 2.2, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawLeafIcon(x,y,scale,stroke){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale, scale);

    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2.6;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.beginPath();
    ctx.moveTo(0, 12);
    ctx.quadraticCurveTo(18, 2, 0, -14);
    ctx.quadraticCurveTo(-18, 2, 0, 12);
    ctx.closePath();
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(0, -12);
    ctx.stroke();

    ctx.restore();
  }

  // ==== –ë–û–ù–£–°–ù–´–ô –¢–ï–ö–°–¢: –í–ï–†–¢–ò–ö–ê–õ–¨–ù–û –ü–û –°–ï–ö–¢–û–†–£, –ù–ï –í–´–õ–ï–ó–ê–ï–¢ ====
  // –ú—ã –ù–ï ‚Äú–∫—Ä—É—Ç–∏–º‚Äù —Ç–µ–∫—Å—Ç –Ω–∞ 90 –≥—Ä–∞–¥—É—Å–æ–≤ (–∫–∞–∫ —Ä–∞–Ω—å—à–µ), –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–Ω —Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–º.
  // –¢—É—Ç –¥–µ–ª–∞–µ–º: rotate(mid) -> translate(r) -> rotate(mid + 90) –ù–ï –ù–£–ñ–ù–û.
  // –ü—Ä–∞–≤–∏–ª—å–Ω–µ–µ: rotate(mid) –∑–∞—Ç–µ–º rotate(PI/2) —á—Ç–æ–±—ã —Ç–µ–∫—Å—Ç –±—ã–ª –≤–¥–æ–ª—å —Ä–∞–¥–∏—É—Å–∞? –ù–µ—Ç.
  // –ù—É–∂–Ω–æ "–≤–¥–æ–ª—å —Å–µ–∫—Ç–æ—Ä–∞" = –≤–¥–æ–ª—å —Ä–∞–¥–∏—É—Å–∞ –Ω–∞—Ä—É–∂—É-–≤–Ω—É—Ç—Ä—å? –û–±—ã—á–Ω–æ —ç—Ç–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ (—Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑) –ø–æ –ª—É—á—É.
  // –°–¥–µ–ª–∞–µ–º —Ç–µ–∫—Å—Ç –≤–¥–æ–ª—å —Ä–∞–¥–∏—É—Å–∞: rotate(mid) -> translate(r) -> rotate(PI/2) –∏ –ø–∏—à–µ–º –ü–û –ë–£–ö–í–ê–ú –≤–Ω–∏–∑.
  function drawVerticalText(text, x, y, maxChars, fill){
    // –†–∏—Å—É–µ–º –ø–æ –±—É–∫–≤–∞–º –≤–Ω–∏–∑ (–≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ)
    const t = text.slice(0, maxChars);
    ctx.save();
    ctx.translate(x,y);
    ctx.fillStyle = fill;
    ctx.font = "900 20px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const lineH = 18;
    const totalH = (t.length-1)*lineH;
    for (let i=0;i<t.length;i++){
      ctx.fillText(t[i], 0, -totalH/2 + i*lineH);
    }
    ctx.restore();
  }

  function drawWheel(highlightIdx=null){
    ctx.clearRect(0,0,W,H);

    // –ª–µ–¥—è–Ω–∞—è –ø–æ–¥–ª–æ–∂–∫–∞
    ctx.save();
    const ice = ctx.createRadialGradient(cx,cy,innerR, cx,cy,outerR*1.05);
    ice.addColorStop(0, "rgba(255,255,255,0.96)");
    ice.addColorStop(0.55, "rgba(220,242,255,0.98)");
    ice.addColorStop(1, "rgba(170,215,245,0.96)");
    ctx.fillStyle = ice;
    ctx.beginPath();
    ctx.arc(cx,cy,outerR*1.05,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // —Ç–µ–º–Ω—ã–π –æ–±–æ–¥
    ctx.save();
    const rimGrad = ctx.createRadialGradient(cx,cy,outerR*0.92, cx,cy,outerR*1.06);
    rimGrad.addColorStop(0, "rgba(18,27,47,0.95)");
    rimGrad.addColorStop(1, "rgba(7,10,18,0.98)");
    ctx.strokeStyle = rimGrad;
    ctx.lineWidth = outerR*0.10;
    ctx.beginPath();
    ctx.arc(cx,cy,outerR*1.02,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // —Å–µ–∫—Ç–æ—Ä—ã
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(angle);

    for (let i=0;i<N;i++){
      const a0 = i*step + startOffset;
      const a1 = a0 + step;
      const sec = sectors[i];
      const isHi = (highlightIdx===i);

      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0, outerR*0.90, a0, a1);
      ctx.closePath();

      ctx.fillStyle = sec.fill;
      ctx.fill();

      if (isHi){
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.fill();
      }

      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 1.1;
      ctx.stroke();

      const mid = (a0+a1)/2;

      // –ò–∫–æ–Ω–∫–∞ –±–ª–∏–∂–µ –∫ –∫—Ä–∞—é
      const iconR = outerR*0.80;
      ctx.save();
      ctx.rotate(mid);
      ctx.translate(iconR, 0);

      // –ò–∫–æ–Ω–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å ‚Äú–±–ª–∏–∂–µ –∫ –≤–µ—Ä—Ö–Ω–µ–π —á–∞—Å—Ç–∏ —Å–µ–∫—Ç–æ—Ä–∞‚Äù ‚Äî —ç—Ç–æ –∫–∞–∫ —Ä–∞–∑ –±–ª–∏–∂–µ –∫ –≤–Ω–µ—à–Ω–µ–º—É —Ä–∞–¥–∏—É—Å—É.
      if (sec.icon === "fish"){
        // —á—É—Ç—å —Å–º–µ—â–∞–µ–º –∫ –∫–æ–Ω—Ü—É —Å–µ–∫—Ç–æ—Ä–∞ (–≤–≤–µ—Ä—Ö)
        drawFishIcon(0, 0, 1.05, "rgba(255,255,255,0.92)");
      } else {
        drawLeafIcon(0, 0, 0.9, "rgba(255,255,255,0.80)");
      }

      // –¢–µ–∫—Å—Ç –±–æ–Ω—É—Å–æ–≤: –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ –ø–æ —Å–µ–∫—Ç–æ—Ä—É –∏ –Ω–µ –≤—ã–ª–µ–∑–∞–µ—Ç
      if (sec.kind === "huge" || sec.kind === "orange" || sec.kind === "blue"){
        // –°–º–µ—â–∞–µ–º —Ç–µ–∫—Å—Ç —á—É—Ç—å –≤–Ω—É—Ç—Ä—å –æ—Ç –∏–∫–æ–Ω–∫–∏, –Ω–æ –≤—Å—ë –µ—â—ë –±–ª–∏–∂–µ –∫ –∫—Ä–∞—é
        const textR = -outerR*0.10;
        // –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Ç–∞–∫, —á—Ç–æ–±—ã –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç ‚Äú–≤–¥–æ–ª—å –ª—É—á–∞‚Äù
        ctx.rotate(Math.PI/2);
        drawVerticalText(sec.label, 0, textR, 10, sec.text);
      }

      ctx.restore();
    }

    ctx.restore();

    // —Ü–µ–Ω—Ç—Ä: —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è —Å–ø–∏–Ω–∞
    if (spinning){
      ctx.save();
      ctx.translate(cx,cy);

      ctx.beginPath();
      ctx.arc(0,0, innerR*1.55, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.08)";
      ctx.lineWidth = 10;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0,0, innerR*1.05, 0, Math.PI*2);
      ctx.fillStyle = "rgba(240,250,255,0.96)";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.10)";
      ctx.lineWidth = 6;
      ctx.stroke();

      ctx.fillStyle = "rgba(11,18,32,0.90)";
      ctx.font = `950 ${Math.floor(innerR*0.38)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ICE", 0, -innerR*0.18);
      ctx.fillText("FISHING", 0, innerR*0.20);

      ctx.restore();
    }

    // ‚Äú–±–æ–ª—Ç–∏–∫–∏‚Äù
    ctx.save();
    ctx.translate(cx,cy);
    const bolts = 18;
    for (let i=0;i<bolts;i++){
      const a = (i/bolts)*Math.PI*2;
      const r = outerR*1.01;
      const x = Math.cos(a)*r;
      const y = Math.sin(a)*r;
      ctx.beginPath();
      ctx.arc(x,y, outerR*0.012, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.22)";
      ctx.fill();
    }
    ctx.restore();
  }

  // ====== –ê–ù–ò–ú–ê–¶–ò–Ø: –ö–ê–ñ–î–´–ô –°–ü–ò–ù –û–î–ò–ù–ê–ö–û–í–û –°–ò–õ–¨–ù–´–ô ======
  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

  // —Ñ–∏–∫—Å–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∞–∂–¥–æ–≥–æ —Å–ø–∏–Ω–∞ (–æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ "–æ—â—É—â–µ–Ω–∏–µ"):
  const SPIN_TURNS = 9;        // –≤—Å–µ–≥–¥–∞ –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ —á–∏—Å–ª–æ –æ–±–æ—Ä–æ—Ç–æ–≤
  const SPIN_MS = 4200;        // –≤—Å–µ–≥–¥–∞ –æ–¥–∏–Ω–∞–∫–æ–≤–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
  const JITTER = 0.18;         // –Ω–µ–±–æ–ª—å—à–æ–π –¥–∂–∏—Ç—Ç–µ—Ä –≤–Ω—É—Ç—Ä–∏ —Å–µ–∫—Ç–æ—Ä–∞ (–¥–æ–ª—è —à–∞–≥–∞)

  function pickWinnerIndexForTick(tick){
    // –ü–æ–∫–∞ –ª–æ–∫–∞–ª—å–Ω–æ: –ø—Å–µ–≤–¥–æ-—Ä–∞–Ω–¥–æ–º –æ—Ç tick (—á—Ç–æ–±—ã –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –±—ã–ª–æ –ø—Ä–∏–º–µ—Ä–Ω–æ –æ–¥–∏–Ω–∞–∫–æ–≤–æ –Ω–∞ –æ–¥–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ)
    // –î–ª—è 100% –æ–¥–∏–Ω–∞–∫–æ–≤–æ —É –≤—Å–µ—Ö ‚Äî –∑–∞–º–µ–Ω–∏–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.
    let x = tick * 1103515245 + 12345;
    x = (x >>> 0);
    return x % N;
  }

  async function spinToWinner(winnerIdx){
    spinning = true;
    setHUDModeSpinning(true);

    const pointerWorld = -Math.PI/2;
    const winnerCenter = (winnerIdx + 0.5)*step + startOffset;
    let target = pointerWorld - winnerCenter;

    // –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±–æ—Ä–æ—Ç–æ–≤ –í–°–ï–ì–î–ê
    const jitter = (pseudoRand01() - 0.5) * step * JITTER;
    target = target + jitter - SPIN_TURNS * Math.PI * 2;

    const start = angle;
    const end = target;
    const t0 = performance.now();

    await new Promise(resolve=>{
      function frame(now){
        const t = Math.min(1,(now-t0)/SPIN_MS);
        const k = easeOutCubic(t);
        angle = start + (end-start)*k;

        drawWheel(indexAtPointer(angle));

        if (t<1) requestAnimationFrame(frame);
        else resolve();
      }
      requestAnimationFrame(frame);
    });

    spinning = false;
    setHUDModeSpinning(false);
    drawWheel(null);

    const finalIdx = indexAtPointer(angle);
    addHistory(finalIdx);
  }

  // –ø—Ä–æ—Å—Ç–æ–π PRNG –¥–ª—è jitter (—á—Ç–æ–±—ã –Ω–µ –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç Math.random –ø—Ä—ã–∂–∫–∞–º–∏)
  let prngState = 123456789;
  function pseudoRand01(){
    prngState = (1664525 * prngState + 1013904223) >>> 0;
    return prngState / 4294967296;
  }

  // ====== HUD (—Ç–∞–π–º–µ—Ä –æ–±—â–∏–π) ======
  const hudMain = document.getElementById("hudMain");
  const hudSub  = document.getElementById("hudSub");

  function setHUDModeSpinning(isSpin){
    if (isSpin){
      hudMain.textContent = "ICE FISHING";
      hudSub.textContent = "spinning";
    } else {
      hudSub.textContent = "–¥–æ —Å–ø–∏–Ω–∞";
    }
  }

  // –≤—ã—á–∏—Å–ª—è–µ–º —Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥ –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ —Ç–∏–∫–∞ –∫–∞–∂–¥—ã–µ 6 —Å–µ–∫
  function secondsToNextTick(nowMs){
    const mod = nowMs % PERIOD_MS;
    const left = PERIOD_MS - mod;
    return Math.ceil(left / 1000);
  }

  let lastTick = null;

  function loop(){
    const now = Date.now();
    const tick = Math.floor(now / PERIOD_MS);

    // —Ç–∞–π–º–µ—Ä –≤—Å–µ–≥–¥–∞ "–≥–ª–æ–±–∞–ª—å–Ω—ã–π" –ø–æ —ç–ø–æ—Ö–µ, –∞ –Ω–µ –æ—Ç –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
    if (!spinning){
      hudMain.textContent = String(secondsToNextTick(now));
    }

    // –ï—Å–ª–∏ —Ç–∏–∫ —Å–º–µ–Ω–∏–ª—Å—è ‚Äî –¥–µ–ª–∞–µ–º —Å–ø–∏–Ω
    if (!spinning && tick !== lastTick){
      lastTick = tick;
      const winner = pickWinnerIndexForTick(tick);
      // –ß—Ç–æ–±—ã –∫–∞–∂–¥—ã–π —Ç–∏–∫ –Ω–∞—á–∏–Ω–∞–ª—Å—è —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ, –¥–∞—ë–º –º–∞–ª–µ–Ω—å–∫–∏–π —Å–¥–≤–∏–≥ –¥–æ –≥—Ä–∞–Ω–∏—Ü—ã —Ç–∏–∫–∞:
      // (–º—ã —É–∂–µ –Ω–∞ –Ω–æ–≤–æ–º —Ç–∏–∫–µ, –∑–∞–ø—É—Å–∫–∞–µ–º —Å—Ä–∞–∑—É)
      spinToWinner(winner);
    }

    requestAnimationFrame(loop);
  }

  // ====== –ò—Å—Ç–æ—Ä–∏—è —Å–Ω–∏–∑—É ======
  const historyBar = document.getElementById("historyBar");
  const history = []; // –ø–æ—Å–ª–µ–¥–Ω–∏–µ N –≤—ã–ø–∞–¥–µ–Ω–∏–π
  const HISTORY_MAX = 18;

  function addHistory(idx){
    history.unshift(idx);
    if (history.length > HISTORY_MAX) history.pop();
    renderHistory();
  }

  function renderHistory(){
    historyBar.innerHTML = "";
    for (const idx of history){
      const sec = sectors[idx];
      const el = document.createElement("div");
      el.className = "chip " + (sec.icon === "fish" ? "fish" : "leaf");
      el.style.background = sec.fill;
      historyBar.appendChild(el);
    }
  }

  // —Å—Ç–∞—Ä—Ç
  drawWheel(null);
  lastTick = Math.floor(Date.now() / PERIOD_MS);
  renderHistory();
  requestAnimationFrame(loop);
</script>
</body>
</html>
