<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IceFishing Wheel</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root{
      --bg1:#eef7ff; --bg2:#cfe6ff;

      --ring1:#0b1220; --ring2:#121b2f;

      --leaf1:#3f4752;  /* темно-серый */
      --leaf2:#9aa3b1;  /* светло-серый */

      --red:#d64545;
      --orange:#f59e0b;
      --blue:#2563eb;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      background:
        radial-gradient(900px 600px at 25% 15%, rgba(255,255,255,.95), rgba(255,255,255,0) 60%),
        radial-gradient(1200px 900px at 70% 35%, rgba(255,255,255,.65), rgba(255,255,255,0) 65%),
        radial-gradient(1400px 900px at 50% 70%, var(--bg1), var(--bg2));
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial;
      overflow:hidden;
    }

    /* левый блок (таймер/название) */
    .leftHUD{
      position:fixed;
      left:12px; top:14px;
      display:flex; align-items:center; gap:10px;
      z-index:5;
      user-select:none;
      pointer-events:none;
    }
    .cube{
      width:34px; height:34px;
      border-radius:10px;
      background: linear-gradient(135deg, rgba(255,255,255,.95), rgba(180,225,255,.75));
      border:1px solid rgba(0,0,0,.10);
      box-shadow: 0 10px 22px rgba(0,0,0,.14);
      position:relative;
    }
    .cube:after{
      content:"";
      position:absolute;
      inset:7px 8px 12px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.65);
      opacity:.9;
    }
    .hudText{
      font-weight:950;
      letter-spacing:.6px;
      color:#0b1220;
      line-height:1;
      min-width:140px;
    }
    .hudText small{
      display:block;
      font-weight:900;
      opacity:.75;
      letter-spacing:.2px;
      margin-top:3px;
      font-size:11px;
    }

    /* сцена */
    .stage{
      position:absolute;
      inset:0;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:18px;
    }
    .wheelWrap{
      position:relative;
      width:min(430px, 92vw);
      height:min(430px, 92vw);
      filter: drop-shadow(0 26px 44px rgba(0,0,0,.25));
    }
    canvas{
      width:100%;
      height:100%;
      border-radius:50%;
    }

    /* указатель сверху */
    .pointer{
      position:absolute;
      top:-8px;
      left:50%;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:16px solid transparent;
      border-right:16px solid transparent;
      border-top:30px solid #0b1220;
      filter: drop-shadow(0 10px 10px rgba(0,0,0,.25));
      pointer-events:none;
    }
    .pointer:after{
      content:"";
      position:absolute;
      left:-10px; top:-28px;
      width:0;height:0;
      border-left:10px solid transparent;
      border-right:10px solid transparent;
      border-top:18px solid rgba(255,255,255,.92);
      opacity:.9;
    }
  </style>
</head>
<body>
  <div class="leftHUD">
    <div class="cube"></div>
    <div class="hudText" id="hudText">
      <span id="hudMain">6</span>
      <small id="hudSub">до спина</small>
    </div>
  </div>

  <div class="stage">
    <div class="wheelWrap">
      <div class="pointer"></div>
      <canvas id="wheel" width="900" height="900"></canvas>
    </div>
  </div>

<script>
  const tg = window.Telegram?.WebApp;
  if (tg) { tg.ready(); tg.expand(); tg.setHeaderColor?.("#eef7ff"); }

  // ====== 53 СЕКТОРА С ТОЧНЫМ РАСПРЕДЕЛЕНИЕМ ======
  const N = 53;
  const step = (Math.PI * 2) / N;
  const startOffset = -Math.PI/2; // сектор 0 — на 12 часов

  // Позиции "как по часам" (приближенно для 53)
  const IDX_HUGE = 0;                 // 12:00
  const IDX_ORANGES = [13, 39];       // 3:00 и 9:00
  const IDX_BLUES   = [7, 20, 33, 46];// 1:30, 4:30, 7:30, 10:30

  const css = getComputedStyle(document.documentElement);
  const COLORS = {
    red:    css.getPropertyValue('--red').trim(),
    orange: css.getPropertyValue('--orange').trim(),
    blue:   css.getPropertyValue('--blue').trim(),
    leaf1:  css.getPropertyValue('--leaf1').trim(),
    leaf2:  css.getPropertyValue('--leaf2').trim(),
  };

  const sectors = Array.from({length:N}, ()=>null);

  sectors[IDX_HUGE] = { kind:"huge", label:"HUGE REDS", fill:COLORS.red, text:"#fff", icon:"fish" };
  for (const i of IDX_ORANGES) sectors[i] = { kind:"orange", label:"BIG ORANGES", fill:COLORS.orange, text:"#1b1b1b", icon:"fish" };
  for (const i of IDX_BLUES)   sectors[i] = { kind:"blue", label:"LIL' BLUES", fill:COLORS.blue, text:"#fff", icon:"fish" };

  // 46 обычных: 23 leaf1 и 23 leaf2, чередуются
  let leaf1Left = 23, leaf2Left = 23;
  let toggle = 0;
  for (let i=0;i<N;i++){
    if (sectors[i]) continue;
    const wantLeaf1 = (toggle % 2 === 0);
    if (wantLeaf1 && leaf1Left > 0){
      sectors[i] = { kind:"leaf1", label:"", fill:COLORS.leaf1, text:"#fff", icon:"leaf" };
      leaf1Left--;
    } else if (!wantLeaf1 && leaf2Left > 0){
      sectors[i] = { kind:"leaf2", label:"", fill:COLORS.leaf2, text:"#fff", icon:"leaf" };
      leaf2Left--;
    } else {
      if (leaf1Left > 0){
        sectors[i] = { kind:"leaf1", label:"", fill:COLORS.leaf1, text:"#fff", icon:"leaf" };
        leaf1Left--;
      } else {
        sectors[i] = { kind:"leaf2", label:"", fill:COLORS.leaf2, text:"#fff", icon:"leaf" };
        leaf2Left--;
      }
    }
    toggle++;
  }

  // ====== CANVAS ======
  const canvas = document.getElementById("wheel");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;

  const outerR = Math.min(W,H)*0.47;
  const innerR = outerR*0.22;

  let angle = 0;
  let spinning = false;

  function normalize(a){
    const t = Math.PI*2;
    return ((a%t)+t)%t;
  }

  function indexAtPointer(a){
    // pointerWorld = -PI/2, startOffset = -PI/2 => при angle=0 индекс 0 сверху
    const pointerWorld = -Math.PI/2;
    const rel = normalize(pointerWorld - a - startOffset);
    return Math.floor(rel / step);
  }

  // ==== ИКОНКИ ====
  function drawFishIcon(x,y,scale,fill){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale, scale);
    ctx.fillStyle = fill;

    ctx.beginPath();
    ctx.ellipse(0, 0, 14, 9, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-14, 0);
    ctx.lineTo(-26, -10);
    ctx.lineTo(-26, 10);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.arc(8, -2, 2.2, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawLeafIcon(x,y,scale,stroke){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale, scale);

    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2.6;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    ctx.beginPath();
    ctx.moveTo(0, 12);
    ctx.quadraticCurveTo(18, 2, 0, -14);
    ctx.quadraticCurveTo(-18, 2, 0, 12);
    ctx.closePath();
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(0, -12);
    ctx.stroke();

    ctx.restore();
  }

  // ==== РИСОВАНИЕ ====
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawWheel(highlightIdx=null){
    ctx.clearRect(0,0,W,H);

    // ледяная подложка
    ctx.save();
    const ice = ctx.createRadialGradient(cx,cy,innerR, cx,cy,outerR*1.05);
    ice.addColorStop(0, "rgba(255,255,255,0.96)");
    ice.addColorStop(0.55, "rgba(220,242,255,0.98)");
    ice.addColorStop(1, "rgba(170,215,245,0.96)");
    ctx.fillStyle = ice;
    ctx.beginPath();
    ctx.arc(cx,cy,outerR*1.05,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // темный обод
    ctx.save();
    const rimGrad = ctx.createRadialGradient(cx,cy,outerR*0.92, cx,cy,outerR*1.06);
    rimGrad.addColorStop(0, "rgba(18,27,47,0.95)");
    rimGrad.addColorStop(1, "rgba(7,10,18,0.98)");
    ctx.strokeStyle = rimGrad;
    ctx.lineWidth = outerR*0.10;
    ctx.beginPath();
    ctx.arc(cx,cy,outerR*1.02,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // секторы
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(angle);

    for (let i=0;i<N;i++){
      const a0 = i*step + startOffset;
      const a1 = a0 + step;
      const sec = sectors[i];
      const isHi = (highlightIdx===i);

      // сектор
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0, outerR*0.90, a0, a1);
      ctx.closePath();

      // БОНУСЫ: заливка целиком цветом (как ты просил)
      // Обычные: серые (чередование)
      let fill = sec.fill;

      // лёгкий “ледяной” блик поверх всех
      ctx.fillStyle = fill;
      ctx.fill();

      // мягкая подсветка
      if (isHi){
        ctx.fillStyle = "rgba(255,255,255,0.10)";
        ctx.fill();
      }

      // разделители
      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.lineWidth = 1.1;
      ctx.stroke();

      // Иконки ближе к внешнему краю (вверх сектора)
      const mid = (a0+a1)/2;
      const iconR = outerR*0.74; // было ближе к центру — теперь ближе к краю

      ctx.save();
      ctx.rotate(mid);
      ctx.translate(iconR, 0);
      ctx.rotate(Math.PI/2);

      if (sec.icon === "fish"){
        drawFishIcon(0, 0, 1.05, "rgba(255,255,255,0.92)");
      } else {
        drawLeafIcon(0, 0, 0.9, "rgba(255,255,255,0.78)");
      }
      ctx.restore();

      // Текст внутри БОНУСНЫХ ячеек (вписан в сектор)
      if (sec.kind === "huge" || sec.kind === "orange" || sec.kind === "blue"){
        const textR = outerR*0.60; // текст чуть ниже иконки, но всё ещё ближе к краю чем к центру
        ctx.save();
        ctx.rotate(mid);
        ctx.translate(textR, 0);
        ctx.rotate(Math.PI/2);

        ctx.fillStyle = sec.text;
        ctx.font = "900 26px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(sec.label, 0, 0);

        ctx.restore();
      }
    }

    ctx.restore();

    // центр — только когда вращается: "ICE FISHING"
    if (spinning){
      ctx.save();
      ctx.translate(cx,cy);

      ctx.beginPath();
      ctx.arc(0,0, innerR*1.55, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.92)";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.08)";
      ctx.lineWidth = 10;
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(0,0, innerR*1.05, 0, Math.PI*2);
      ctx.fillStyle = "rgba(240,250,255,0.96)";
      ctx.fill();
      ctx.strokeStyle = "rgba(0,0,0,0.10)";
      ctx.lineWidth = 6;
      ctx.stroke();

      ctx.fillStyle = "rgba(11,18,32,0.90)";
      ctx.font = `950 ${Math.floor(innerR*0.38)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ICE", 0, -innerR*0.18);
      ctx.fillText("FISHING", 0, innerR*0.20);

      ctx.restore();
    }

    // “болтики” на ободе
    ctx.save();
    ctx.translate(cx,cy);
    const bolts = 18;
    for (let i=0;i<bolts;i++){
      const a = (i/bolts)*Math.PI*2;
      const r = outerR*1.01;
      const x = Math.cos(a)*r;
      const y = Math.sin(a)*r;
      ctx.beginPath();
      ctx.arc(x,y, outerR*0.012, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.22)";
      ctx.fill();
    }
    ctx.restore();
  }

  // ====== АВТО-СПИН КАЖДЫЕ 6 СЕК ======
  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

  function pickWinnerIndex(){
    // пока равновероятно по 53
    return Math.floor(Math.random()*N);
  }

  async function spin(){
    if (spinning) return;
    spinning = true;
    setHUDModeSpinning(true);

    const winner = pickWinnerIndex();

    // хотим победителя под указатель (верх)
    const pointerWorld = -Math.PI/2;
    const winnerCenter = (winner + 0.5)*step + startOffset;
    let target = pointerWorld - winnerCenter;

    const extraTurns = 7 + Math.floor(Math.random()*4); // 7–10
    const jitter = (Math.random()-0.5)*step*0.25;
    target = target + jitter - extraTurns*Math.PI*2;

    const start = angle;
    const end = target;

    const duration = 4200; // чтобы уложиться и оставалось время до следующего спина
    const t0 = performance.now();

    await new Promise(resolve=>{
      function frame(now){
        const t = Math.min(1,(now-t0)/duration);
        const k = easeOutCubic(t);
        angle = start + (end-start)*k;

        const hi = indexAtPointer(angle);
        drawWheel(hi);

        if (t<1) requestAnimationFrame(frame);
        else resolve();
      }
      requestAnimationFrame(frame);
    });

    spinning = false;
    setHUDModeSpinning(false);
    drawWheel(null);
  }

  // ====== HUD: таймер vs ICE FISHING ======
  const hudMain = document.getElementById("hudMain");
  const hudSub  = document.getElementById("hudSub");

  let countdown = 6;
  let timerId = null;

  function setHUDModeSpinning(isSpin){
    if (isSpin){
      hudMain.textContent = "ICE FISHING";
      hudSub.textContent = "spinning";
    } else {
      hudMain.textContent = String(countdown);
      hudSub.textContent = "до спина";
    }
  }

  function startCountdownLoop(){
    // каждые 1 сек обновляем цифру
    timerId = setInterval(async ()=>{
      if (spinning) return; // во время спина HUD уже ICE FISHING
      countdown -= 1;
      if (countdown <= 0){
        countdown = 6; // сразу сброс на следующий цикл
        // запускаем спин
        spin();
      }
      setHUDModeSpinning(false);
    }, 1000);
  }

  // старт: отрисовать и запустить
  drawWheel(null);
  startCountdownLoop();

  // чтобы сразу через 6 секунд первый спин (и показалось что “живое”)
  // если хочешь первый спин сразу — раскомментируй:
  // spin();
</script>
</body>
</html>
