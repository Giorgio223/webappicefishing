<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IceFishing Wheel</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root{
      --bg1:#eef7ff; --bg2:#cfe6ff;
      --ring:#0b1220; --ring2:#121b2f;
      --ice1:#e9f6ff; --ice2:#9ad4ff;
      --leaf1:#424b57; --leaf2:#8b95a4;
      --red:#d64545; --orange:#f59e0b; --blue:#2563eb;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      background:
        radial-gradient(900px 600px at 25% 15%, rgba(255,255,255,.95), rgba(255,255,255,0) 60%),
        radial-gradient(1200px 900px at 70% 35%, rgba(255,255,255,.65), rgba(255,255,255,0) 65%),
        radial-gradient(1400px 900px at 50% 70%, var(--bg1), var(--bg2));
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial;
      overflow:hidden;
    }

    /* Левый бренд (как просил) */
    .brand{
      position:fixed;
      left:12px; top:14px;
      display:flex; align-items:center; gap:10px;
      z-index:5;
      user-select:none;
      pointer-events:none;
    }
    .cube{
      width:34px; height:34px;
      border-radius:10px;
      background:
        linear-gradient(135deg, rgba(255,255,255,.95), rgba(180,225,255,.75));
      border:1px solid rgba(0,0,0,.10);
      box-shadow: 0 10px 22px rgba(0,0,0,.14);
      position:relative;
    }
    .cube:after{
      content:"";
      position:absolute;
      inset:7px 8px 12px 8px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.65);
      opacity:.9;
    }
    .brand .text{
      font-weight:950;
      letter-spacing:.6px;
      color:#0b1220;
      line-height:1;
    }
    .brand .text small{
      display:block;
      font-weight:900;
      opacity:.75;
      letter-spacing:.2px;
      margin-top:3px;
      font-size:11px;
    }

    /* Сцена с колесом */
    .stage{
      position:absolute;
      inset:0;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:18px;
    }
    .wheelWrap{
      position:relative;
      width:min(430px, 92vw);
      height:min(430px, 92vw);
      filter: drop-shadow(0 26px 44px rgba(0,0,0,.25));
    }
    canvas{
      width:100%;
      height:100%;
      border-radius:50%;
      cursor:pointer;
      touch-action: manipulation;
    }

    /* указатель сверху */
    .pointer{
      position:absolute;
      top:-8px;
      left:50%;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:16px solid transparent;
      border-right:16px solid transparent;
      border-top:30px solid #0b1220;
      filter: drop-shadow(0 10px 10px rgba(0,0,0,.25));
      pointer-events:none;
    }
    .pointer:after{
      content:"";
      position:absolute;
      left:-10px; top:-28px;
      width:0;height:0;
      border-left:10px solid transparent;
      border-right:10px solid transparent;
      border-top:18px solid rgba(255,255,255,.92);
      opacity:.9;
    }

    /* маленькая подсказка (не “результат”) */
    .hint{
      position:fixed;
      left:12px;
      bottom:12px;
      z-index:5;
      background: rgba(255,255,255,.70);
      border:1px solid rgba(0,0,0,.08);
      border-radius:14px;
      padding:10px 12px;
      font-weight:850;
      color:#0b1220;
      box-shadow: 0 12px 26px rgba(0,0,0,.12);
      user-select:none;
      pointer-events:none;
      font-size:12px;
      opacity:.9;
    }
  </style>
</head>
<body>
  <div class="brand">
    <div class="cube"></div>
    <div class="text">ICE FISHING<small>tap wheel to spin</small></div>
  </div>

  <div class="stage">
    <div class="wheelWrap">
      <div class="pointer"></div>
      <canvas id="wheel" width="900" height="900" aria-label="wheel"></canvas>
    </div>
  </div>

  <div class="hint">Нажми на колесо, чтобы крутить</div>

<script>
  const tg = window.Telegram?.WebApp;
  if (tg) { tg.ready(); tg.expand(); tg.setHeaderColor?.("#eef7ff"); }

  // ====== СХЕМА СЕКТОРОВ: 53 ======
  const N = 53;
  const step = (Math.PI * 2) / N;

  // Индексы, приближенные к "часам" при 53 секторах:
  // 12:00 ~ 0
  // 3:00  ~ 13
  // 9:00  ~ 39
  // 1:30  ~ 7
  // 4:30  ~ 20
  // 7:30  ~ 33
  // 10:30 ~ 46
  const IDX_HUGE = 0;
  const IDX_ORANGES = [13, 39];
  const IDX_BLUES   = [7, 20, 33, 46];

  const kindAt = Array(N).fill(null);
  kindAt[IDX_HUGE] = {kind:"huge", label:"HUGE REDS", color:getComputedStyle(document.documentElement).getPropertyValue('--red').trim(), text:"#fff", icon:"fish"};
  for (const i of IDX_ORANGES) kindAt[i] = {kind:"orange", label:"BIG ORANGES", color:getComputedStyle(document.documentElement).getPropertyValue('--orange').trim(), text:"#1b1b1b", icon:"fish"};
  for (const i of IDX_BLUES)   kindAt[i] = {kind:"blue", label:"LIL' BLUES", color:getComputedStyle(document.documentElement).getPropertyValue('--blue').trim(), text:"#fff", icon:"fish"};

  // Заполняем оставшиеся 46 как Leaf1/Leaf2 (23/23), строго чередуя
  let leaf1Left = 23, leaf2Left = 23;
  let toggle = 0;
  for (let i=0;i<N;i++){
    if (kindAt[i]) continue;
    const useLeaf1 = (toggle % 2 === 0);
    if (useLeaf1 && leaf1Left > 0){
      kindAt[i] = {kind:"leaf1", label:"", color:getComputedStyle(document.documentElement).getPropertyValue('--leaf1').trim(), text:"#fff", icon:"leaf"};
      leaf1Left--;
    } else if (!useLeaf1 && leaf2Left > 0){
      kindAt[i] = {kind:"leaf2", label:"", color:getComputedStyle(document.documentElement).getPropertyValue('--leaf2').trim(), text:"#fff", icon:"leaf"};
      leaf2Left--;
    } else {
      // если один закончился — докидываем остаток другим
      if (leaf1Left > 0){
        kindAt[i] = {kind:"leaf1", label:"", color:getComputedStyle(document.documentElement).getPropertyValue('--leaf1').trim(), text:"#fff", icon:"leaf"};
        leaf1Left--;
      } else {
        kindAt[i] = {kind:"leaf2", label:"", color:getComputedStyle(document.documentElement).getPropertyValue('--leaf2').trim(), text:"#fff", icon:"leaf"};
        leaf2Left--;
      }
    }
    toggle++;
  }

  // ====== CANVAS ======
  const canvas = document.getElementById("wheel");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;
  const cx = W/2, cy = H/2;
  const outerR = Math.min(W,H)*0.47;
  const rimR   = outerR*1.02;
  const innerR = outerR*0.22;

  // Угол колеса
  let angle = 0;
  let spinning = false;

  // Ориентация: чтобы сектор 0 был на 12 часов при angle=0
  const startOffset = -Math.PI/2; // верх

  function normalize(a){
    const t = Math.PI*2;
    return ((a%t)+t)%t;
  }

  // индекс под указателем (верх)
  function indexAtPointer(a){
    // pointerWorld = -PI/2, но мы уже используем startOffset=-PI/2 при отрисовке
    // поэтому индекс считаем так, чтобы при angle=0 -> idx=0
    const pointerWorld = -Math.PI/2;
    const rel = normalize(pointerWorld - a - startOffset);
    return Math.floor(rel / step);
  }

  // Иконка рыбки (простая силуэтная, маленькая)
  function drawFishIcon(x,y,scale,fill){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale, scale);

    ctx.fillStyle = fill;

    // тело (овал)
    ctx.beginPath();
    ctx.ellipse(0, 0, 14, 9, 0, 0, Math.PI*2);
    ctx.fill();

    // хвост (треугольник)
    ctx.beginPath();
    ctx.moveTo(-14, 0);
    ctx.lineTo(-26, -10);
    ctx.lineTo(-26, 10);
    ctx.closePath();
    ctx.fill();

    // глаз
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.arc(8, -2, 2.2, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  // Иконка листика (простая)
  function drawLeafIcon(x,y,scale,stroke){
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(scale, scale);

    ctx.strokeStyle = stroke;
    ctx.lineWidth = 2.6;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    // контур листа
    ctx.beginPath();
    ctx.moveTo(0, 12);
    ctx.quadraticCurveTo(18, 2, 0, -14);
    ctx.quadraticCurveTo(-18, 2, 0, 12);
    ctx.closePath();
    ctx.stroke();

    // прожилка
    ctx.beginPath();
    ctx.moveTo(0, 10);
    ctx.lineTo(0, -12);
    ctx.stroke();

    ctx.restore();
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    ctx.closePath();
  }

  function drawWheel(highlightIdx=null){
    ctx.clearRect(0,0,W,H);

    // ледяная подложка
    ctx.save();
    const ice = ctx.createRadialGradient(cx,cy,innerR, cx,cy,outerR*1.05);
    ice.addColorStop(0, "rgba(255,255,255,0.95)");
    ice.addColorStop(0.55, "rgba(220,242,255,0.98)");
    ice.addColorStop(1, "rgba(170,215,245,0.96)");
    ctx.fillStyle = ice;
    ctx.beginPath();
    ctx.arc(cx,cy,outerR*1.05,0,Math.PI*2);
    ctx.fill();
    ctx.restore();

    // тёмный обод
    ctx.save();
    const rimGrad = ctx.createRadialGradient(cx,cy,outerR*0.92, cx,cy,outerR*1.06);
    rimGrad.addColorStop(0, "rgba(18,27,47,0.95)");
    rimGrad.addColorStop(1, "rgba(7,10,18,0.98)");
    ctx.strokeStyle = rimGrad;
    ctx.lineWidth = outerR*0.10;
    ctx.beginPath();
    ctx.arc(cx,cy,outerR*1.02,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // секторы
    ctx.save();
    ctx.translate(cx,cy);
    ctx.rotate(angle);

    for (let i=0;i<N;i++){
      const a0 = i*step + startOffset;
      const a1 = a0 + step;
      const sec = kindAt[i];
      const isHi = (highlightIdx===i);

      // форма сектора
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0, outerR*0.90, a0, a1);
      ctx.closePath();

      if (sec.kind === "leaf1" || sec.kind === "leaf2"){
        // серые листы (чередование)
        const g = ctx.createRadialGradient(0,0,innerR,0,0,outerR*0.95);
        g.addColorStop(0, "rgba(255,255,255,0.55)");
        g.addColorStop(1, sec.color);
        ctx.fillStyle = g;
        ctx.fill();
      } else {
        // бонусные сектора всё равно сидят на “ледяном” фоне, а баннер — отдельно
        const g = ctx.createRadialGradient(0,0,innerR,0,0,outerR*0.95);
        g.addColorStop(0, "rgba(255,255,255,0.82)");
        g.addColorStop(1, "rgba(120,185,235,0.55)");
        ctx.fillStyle = g;
        ctx.fill();
      }

      // подсветка “текущего” под указателем (очень мягко)
      if (isHi){
        ctx.fillStyle = "rgba(255,255,255,0.12)";
        ctx.fill();
      }

      // разделители
      ctx.strokeStyle = "rgba(255,255,255,0.20)";
      ctx.lineWidth = 1.2;
      ctx.stroke();

      // ИКОНКИ: рыбка на бонусах, листик на обычных
      const mid = (a0+a1)/2;
      const iconR = outerR*0.58;

      ctx.save();
      ctx.rotate(mid);
      ctx.translate(iconR, 0);
      ctx.rotate(Math.PI/2);

      if (sec.icon === "fish"){
        drawFishIcon(0, 0, 1.05, "rgba(255,255,255,0.92)");
      } else {
        drawLeafIcon(0, 0, 0.9, "rgba(255,255,255,0.78)");
      }
      ctx.restore();
    }

    // БАННЕРЫ на бонусах (как на скрине)
    for (let i=0;i<N;i++){
      const sec = kindAt[i];
      if (!(sec.kind === "huge" || sec.kind === "orange" || sec.kind === "blue")) continue;

      const mid = (i+0.5)*step + startOffset;

      ctx.save();
      ctx.rotate(mid);

      const bannerW = outerR*0.60;
      const bannerH = outerR*0.12;
      const r = outerR*0.76;

      ctx.translate(r, 0);
      ctx.rotate(Math.PI/2);

      // тень
      ctx.save();
      ctx.translate(0, 4);
      ctx.globalAlpha = 0.33;
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      roundRect(-bannerW/2, -bannerH/2, bannerW, bannerH, bannerH*0.45);
      ctx.fill();
      ctx.restore();

      // заливка
      ctx.fillStyle = sec.color;
      roundRect(-bannerW/2, -bannerH/2, bannerW, bannerH, bannerH*0.45);
      ctx.fill();

      // “ушки”
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.beginPath();
      ctx.moveTo(-bannerW/2, -bannerH/2);
      ctx.lineTo(-bannerW/2 - bannerH*0.35, 0);
      ctx.lineTo(-bannerW/2, bannerH/2);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(bannerW/2, -bannerH/2);
      ctx.lineTo(bannerW/2 + bannerH*0.35, 0);
      ctx.lineTo(bannerW/2, bannerH/2);
      ctx.closePath();
      ctx.fill();

      // текст
      ctx.fillStyle = sec.text;
      ctx.font = `900 ${Math.floor(bannerH*0.48)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(sec.label, 0, 1);

      ctx.restore();
    }

    ctx.restore();

    // Центр (без "результата", просто эмблема)
    ctx.save();
    ctx.translate(cx,cy);

    ctx.beginPath();
    ctx.arc(0,0, innerR*1.55, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.08)";
    ctx.lineWidth = 10;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(0,0, innerR*1.05, 0, Math.PI*2);
    ctx.fillStyle = "rgba(240,250,255,0.96)";
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.10)";
    ctx.lineWidth = 6;
    ctx.stroke();

    ctx.fillStyle = "rgba(11,18,32,0.90)";
    ctx.font = `950 ${Math.floor(innerR*0.38)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("ICE", 0, -innerR*0.18);
    ctx.fillText("FISHING", 0, innerR*0.20);

    ctx.restore();

    // “болтики” на ободе
    ctx.save();
    ctx.translate(cx,cy);
    const bolts = 18;
    for (let i=0;i<bolts;i++){
      const a = (i/bolts)*Math.PI*2;
      const r = outerR*1.01;
      const x = Math.cos(a)*r;
      const y = Math.sin(a)*r;
      ctx.beginPath();
      ctx.arc(x,y, outerR*0.012, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,0.22)";
      ctx.fill();
    }
    ctx.restore();
  }

  // ====== SPIN: без кнопок, запускается кликом по колесу ======
  function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

  // Пока равная вероятность. Дальше можем сделать веса “как у провайдера”.
  function pickWinnerIndex(){
    return Math.floor(Math.random()*N);
  }

  async function spin(){
    if (spinning) return;
    spinning = true;

    const winner = pickWinnerIndex();

    // хотим победителя под указатель (верх)
    const pointerWorld = -Math.PI/2;
    const winnerCenter = (winner + 0.5)*step + startOffset;
    let target = pointerWorld - winnerCenter;

    const extraTurns = 7 + Math.floor(Math.random()*4); // 7–10
    const jitter = (Math.random()-0.5)*step*0.25;
    target = target + jitter - extraTurns*Math.PI*2;

    const start = angle;
    const end = target;

    const duration = 5200 + Math.floor(Math.random()*900);
    const t0 = performance.now();

    await new Promise(resolve=>{
      function frame(now){
        const t = Math.min(1,(now-t0)/duration);
        const k = easeOutCubic(t);
        angle = start + (end-start)*k;

        const hi = indexAtPointer(angle);
        drawWheel(hi);

        if (t<1) requestAnimationFrame(frame);
        else resolve();
      }
      requestAnimationFrame(frame);
    });

    // Никаких “результатов” на экране — как ты просил.
    // Но если позже нужно отправлять в бота:
    // const finalIdx = indexAtPointer(angle);
    // tg?.sendData?.(JSON.stringify({ idx: finalIdx, kind: kindAt[finalIdx].kind }));

    spinning = false;
  }

  canvas.addEventListener("click", spin);
  canvas.addEventListener("touchend", (e)=>{ e.preventDefault(); spin(); }, {passive:false});

  drawWheel(null);
</script>
</body>
</html>
